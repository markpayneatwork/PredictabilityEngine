---
output:
  html_document:
    keep_md: false
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: inline
params:
  set_title: Statistics and Forecast Skill Visualisations
---

---
title: `r params$set_title`
---
```{r setup, include="FALSE"}
#'========================================================================
# Visualise skill metrics
#'========================================================================
#
# by Mark R Payne
# DTU-Aqua, Kgs. Lyngby, Denmark
# http://www.staff.dtu.dk/mpay
#
# Created Wed May  1 10:48:18 2019
#
# Makes a series of generic skill visualisations
#
# This work is subject to a Creative Commons "Attribution" "ShareALike" License.
# You are largely free to do what you like with it, so long as you "attribute"
# me for my contribution. See the fine print at the end for exact details.
#
# To do:
#
# Notes:
#   Make sure when knitting that you have the Knit directory set to "project directory"
#'========================================================================

#Clean plate
rm(list=ls())

#Load packages
library(tidyverse)
library(PredEng)
library(mapdata)
library(sf)
library(ggplot2)
library(scales)

#GGplot config
theme_set(theme_bw(base_size = 14))

#Configure Knitr
knitr::opts_chunk$set(
  echo=FALSE,
	error = FALSE,
	message = FALSE,
	warning = FALSE,
	include = TRUE,
	results = "markup",
	fig.width = 10,
	fig.height=14/25*10,
  fig.align="center")

#Powerpoint needs 14 x 25cm figures

#knitr::opts_knit$set(root.dir=getwd())
#cat(sprintf("title: %s skill visualisation\n",pcfg@project.name))

```

by Mark R Payne  <br>
DTU-Aqua, Kgs. Lyngby, Denmark  <br>
http://www.staff.dtu.dk/mpay  <br>
```{r results="asis"}
cat(sprintf("Visualisations generated  %s\n",date()))
```


## Configuration

```{r}
#==========================================================================
# Configure
#==========================================================================
pcfg <- readRDS(PE.cfg$config.path)
show(pcfg)

#'========================================================================
# Setup ####
#'========================================================================
#Import data
base.dir <- pcfg@scratch.dir
skill.mets.all <- readRDS(file.path(base.dir,PE.cfg$files$scalar.skill.metrics))
stat.dat <- readRDS(file.path(base.dir,PE.cfg$files$scalar.stats))

#Rescale time axis
rescale.fn <- function(m) {  #Converts a leadtime in months into a rescale value
  ifelse(m>12,
         rescale(m,from=c(12,120),to=c(1,2)),
         rescale(m,from=c(0,12),to=c(0,1)))
}

skill.mets <- ungroup(skill.mets.all) %>%
              filter(skill.type=="mean.skill",
                     src.type!="Observations") %>%
              mutate(t=rescale.fn(lead),
                     ensmean=src.name=="Ensmean"|src.type=="Persistence")%>%
              unite(src.type.name,src.type,src.name,remove=FALSE)

field.skill.mets <- ungroup(skill.mets.all) %>%
                filter(skill.type=="field")

#Plot misc!
x.lbls <- tibble(months=c(seq(0,12,by=3),seq(24,120,by=24)),t=rescale.fn(months)) %>%
  mutate(lbl=ifelse(months<=12,sprintf("%g m",months),
                    sprintf("%g y",months/12)))
x.minor <- tibble(months=c(0:12,seq(24,120,by=12)),t=rescale.fn(months))


```



```{r results="asis"}
#'========================================================================
# Field skills ####
#'========================================================================
if(nrow(field.skill.mets)>0) {
    cat("## Field statistics\n")
  
  #For simplicity, we only look at the skill of the ensemble mean
  ensmean.field.skill <- field.skill.mets %>%
                          filter(src.name==PE.cfg$files$ensmean.name) 
  
  #Now extract the raster-based skill fields into a format ready for plotting
  plt.dat.all <- rowwise(ensmean.field.skill) %>%
    group_split() %>%
    lapply(function(x) {
      rast.df <- rasterToPoints(x$field.skill[[1]])
      colnames(rast.df)[3] <- "skill"
      cbind(x,rast.df)}) %>%
    bind_rows() %>%
    as_tibble() %>%
    dplyr::select(-src.name,-sp.subdomain,-skill.type,-value,-field.skill) 
  
  #Now split into plots
  plt.dat.stat <- group_by(plt.dat.all) %>% group_split(stat.name)
  for(this.stat.dat in plt.dat.stat) {
    cat(sprintf("\n\n### %s\n",unique(this.stat.dat$stat.name)))

    #Now split into the individual plots
    plt.dat.l <- group_by(this.stat.dat,src.type,skill.metric) %>% group_split()
    for(plt.dat in plt.dat.l) {
      g <- ggplot(plt.dat,aes(x,y,fill=skill))+
        geom_raster()+
        facet_wrap(~lead)+
        coord_quickmap()+
        annotation_map(map_data("world"))+
        scale_fill_viridis_c()+
        labs(fill=unique(plt.dat$skill.metric),x="",y="")+
        ggtitle(unique(plt.dat$src.type))
      print(g)
      
      
    }
    
    
  }
  
    
  
}

#'========================================================================
# Stat skills ####
#'========================================================================
#Present results by spatial region
sp.skill.l <- split(skill.mets,skill.mets$sp.subdomain)

for(this.sp in names(sp.skill.l)) {
  #Extract data 
  sp.dat <- sp.skill.l[[this.sp]]
  
  #Show title
  cat(sprintf("\n\n## %s\n",gsub("_"," ",this.sp)))
  
  #Map of the Spatial region
  if(this.sp==PE.cfg$misc$global.sp.name) {
    #Use the global ROI
    sp.obj <- spatial.domain(pcfg@global.ROI,
                            name=PE.cfg$misc$global.sp.name)
  } else {
    #Use the normal object
    sp.obj <- pcfg@spatial.domains[[this.sp]]
  }
  xtent <- extend(extent(sp.obj),10)
  g <- ggplot()+
    geom_sf(data=st_as_sf(sp.obj@boundary)) +
    annotation_map(map_data("worldHires"),fill="black",colour="grey")+
    coord_sf(xlim=xtent[1:2],ylim=xtent[3:4])
  print(g)
  
  #Now split it down further into Individual statistics and loop
  sp.ss.dat.l <- split(sp.dat,sp.dat[,"stat.name"]) 
  for(this.ss in names(sp.ss.dat.l)) {
    #Show a subtitle
    cat(sprintf("\n\n### %s\n",this.ss))
    
    #Extract the corresponding stat data and plot it
    stat.sel <- filter(stat.dat,
                          sp.subdomain==this.sp,
                          stat.name==this.ss)
    stat.obs <- filter(stat.sel,
                            src.type=="Observations",
                            year(date)>=min(pcfg@comp.years)) %>%
                    mutate(timeframe="Historical")
    mr.obs <- max(stat.obs$date)
    stat.mdl <- filter(stat.sel,
                          date>mr.obs,
                          src.type %in% c("Decadal","NMME"),
                          src.name!="Ensmean") %>%
                   mutate(timeframe="Near-term predictions",
                          name.type=paste(src.name,src.type,sep=".")) %>%
                   group_by(name.type) %>%
                   filter(start.date==max(start.date)) %>%
                   ungroup() %>%
                   dplyr::select(-name.type) 

    stat.plt.dat <- rbind(stat.obs,stat.mdl)
    
    g <- ggplot(stat.plt.dat,aes(x=date,y=value,colour=src.name))+
         geom_line()+
         labs(x="Year",y=this.ss)+
         facet_wrap(~timeframe,nrow=1,scales="free_x")
    print(g)    
    
    #Split skill data into metrics 
    sp.ss.dat <- sp.ss.dat.l[[this.ss]]
    sp.ss.sk.dat.l <- split(sp.ss.dat,sp.ss.dat[,c("skill.metric")])
    
    
    #Iterate over skill metrics
    for(this.sk in names(sp.ss.sk.dat.l)) {
      #Get data
      plt.dat <- sp.ss.sk.dat.l[[this.sk]]

      #Set y range accordingly
      if(this.sk=="cor") {
        y.rng <- c(0,1)
      } else {
        y.rng <- range(pretty(c(0,plt.dat$value)))
      }
      
      #Plot
      g <- ggplot(plt.dat,aes(x=t,y=value,group=src.type.name))+
        geom_line(aes(colour=src.type,size=ensmean))+
        facet_wrap(~skill.metric,scales = "free_y")+
        coord_cartesian(xlim=c(0,2),ylim=y.rng,expand=FALSE)+
        scale_size_manual(values=c(0.25,1))+
        guides(size=FALSE)+
        scale_x_continuous(breaks=x.lbls$t,
                           labels=x.lbls$lbl,
                           minor_breaks = x.minor$t)+
        labs(x="Lead time (months / years)",y=this.sk,colour="Forecast System")
      print(g)

    }  #Plot  
    
  }
  

}

```





***
*This work by Mark R Payne is licensed under a  Creative Commons
Attribution-NonCommercial-ShareAlike 3.0 Unported License. 
For details, see http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US
Basically, this means that you are free to "share" and "remix" for 
non-commerical purposes as you see fit, so long as you "attribute" me for my
contribution. Derivatives can be distributed under the same or 
similar license.*

*This work comes with ABSOLUTELY NO WARRANTY or support.*

***



